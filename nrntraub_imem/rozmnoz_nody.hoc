strdef dir
setuptime = 1
dir  = "/home/hglabska/data2/artykul_data/git/Thalamocortical_imem/nrntraub_imem/dat/nodes/test_7.2/"


load_file("hoc/defvar.hoc")
active_ions = 0
load_file("hoc/traubcon.hoc")
load_file("mylib/shape3d/extra_shapes.hoc")
load_file("cells/deepaxax_template.hoc")
load_file("cells/deepbask_template.hoc")
load_file("cells/deepLTS_template.hoc")
load_file("cells/nontuftRS_template.hoc")
load_file("cells/nRT_template.hoc")
load_file("cells/spinstell_template.hoc")
load_file("cells/supaxax_template.hoc")
load_file("cells/supbask_template.hoc")
load_file("cells/supLTS_template.hoc")
load_file("cells/suppyrFRB_template.hoc")
load_file("cells/suppyrRS_template.hoc")
load_file("cells/TCR_template.hoc")
load_file("cells/tuftIB_template.hoc")
load_file("cells/tuftRS_template.hoc")
serial = 1
load_file("net/durand.hoc")

one_tenth_ncell = 0



        cells_type = 14
        objref Map_names, Num_pop
        {Map_names = new List()
        Map_names.append(new String("suppyrRS"))
        Map_names.append(new String("suppyrFRB"))
        Map_names.append(new String("supbask"))
        Map_names.append(new String("supaxax"))
        Map_names.append(new String("supLTS"))
        Map_names.append(new String("spinstell"))
        Map_names.append(new String("tuftIB"))
        Map_names.append(new String("tuftRS"))
        Map_names.append(new String("nontuftRS"))
        Map_names.append(new String("deepbask"))
        Map_names.append(new String("deepaxax"))
        Map_names.append(new String("deepLTS"))
        Map_names.append(new String("TCR"))
        Map_names.append(new String("nRT"))}

        {Num_pop = new Vector()


Num_pop.append(1000,50,90,90,90,240,800,200,500,100,100,100,100,100)}


  num_suppyrRS = 1000
        num_suppyrFRB =  50
        num_supbask = 90
        num_supaxax = 90
        num_supLTS = 90
        num_spinstell = 240
        num_tuftIB = 800
        num_tuftRS = 200
        num_nontuftRS = 500
        num_deepbask = 100
        num_deepaxax = 100
        num_deepLTS = 100
        num_TCR = 100
        num_nRT = 100

if (one_tenth_ncell) {
        num_suppyrRS /= 10
        num_suppyrFRB /= 10
        num_supbask /= 10
        num_supaxax /= 10
        num_supLTS /= 10
        num_spinstell /= 10
        num_tuftIB /= 10
        num_tuftRS /= 10
        num_nontuftRS /= 10
        num_deepbask /= 10
        num_deepaxax /= 10
        num_deepLTS /= 10
        num_TCR /= 10
        num_nRT /= 10
        Num_pop.div(10)}


       numcomp_suppyrRS   = 74
        numcomp_suppyrFRB  = 74
        numcomp_supbask    = 59
        numcomp_supaxax    = 59
        numcomp_supLTS     = 59
        numcomp_spinstell  = 59
        numcomp_tuftIB     = 61
        numcomp_tuftRS     = 61
        numcomp_nontuftRS  = 50
        numcomp_deepbask   = 59
        numcomp_deepaxax   = 59
        numcomp_deepLTS    = 59
        numcomp_TCR        =137
        numcomp_nRT        = 59

powtorzenia = 1

szerokosc_kolumny = 400
promien_kolumny = szerokosc_kolumny/2

objref randobjr, randobj0

randobjr = new Random(1)
randobjr.uniform(4/promien_kolumny,1)
randobj0 = new Random(1234)
randobj0.uniform(0,1)



//glebokosc poszczegolnych warstw kory
glebokosc_poziomu23 = 400
glebokosc_poziomu4 =  300
glebokosc_poziomu5 = 500
glebokosc_poziomu6 = 500

glebokosc_kolumny = glebokosc_poziomu23 + glebokosc_poziomu4 + glebokosc_poziomu5 + glebokosc_poziomu6

//jak jest przesuni�^�ta dana warstwa kory w stosunku do powierczchni 2. warstwy
poziom23 = -glebokosc_poziomu23
poziom4 =  -glebokosc_poziomu23-glebokosc_poziomu4
poziom5 =  -glebokosc_poziomu23-glebokosc_poziomu4-glebokosc_poziomu5
poziom6 =  -glebokosc_kolumny


//create_cell(nawa_komorki, liczbka_komorek, random_deep ,przesuniecie_w_pionie)
//procedura  tworz�^�ca grup�^� komórek o liczno�^�ci liczba_komórek, typu nazwa_komórki

objref proby,my_cell, geometry
proby = new File()
geometry = new File()
strdef str2, str1, str3


proc write_nodes(){local i, alpha_, coorx, coory, coorz, beta, r
        //my_cell = new List()
        strdef proc_exec
        proby.aopen(str2)
        geometry.aopen(str3)
        sprint(str1,"my_cell = new %s(0)",$s1)
        print $s1
        print str1
        //my_cell.append(new suppyrRS(0))
        print "ok"
        if (serial) {
              //print serial, "SSSSSSSSSSSSSS"
             execute(str1)
           } else {
              sprint(proc_exec,"new %s(0)",$s1)
              par_create(proc_exec)


           }

        for i=0, $2-1 {
                //proby.printf("%d\t", base_)
              //kat o ktory obroce komorke w poziomie  - funkcja rotation w szablonie danej komórki (katalog cells)

              alpha_ = randobj0.repick()*360
              //kat potrzebny do wyznaczenia wspolrzednych biegunowych
              beta_ = randobj0.repick()*360

              r = sqrt(randobjr.repick())*promien_kolumny

              //[coory, coorz, coorx] wektor o ktory przesune komorke (funkcaja position() w szablonie danej komórki)
              coorx = r*cos(beta_)
              coory = r*sin(beta_)
              coorz = randobj0.repick()*$3 + $4
              //coorz = $o3.x(i)
              x = my_cell.x
              y = my_cell.y
              z = my_cell.z

                //}
              forall{
                        comp = 0
                        sscanf(secname(), "%*[^0-9]%*d%*[^0-9]%d",&comp)
                        n_ =  n3d() -1

                        for l = 0,nseg-1{
                                tmp = (l   +0.5)/nseg
                                x0 =(x3d(0)*cos(alpha_) - z3d(0)*sin(alpha_) - x) +  coory
                                xn =  (x3d(n_)*cos(alpha_) - z3d(n_)*sin(alpha_) - x) +  coory
                                y0 = (y3d(0) - y) + coorz
                                yn = (y3d(n_) - y) + coorz
                                z0 = (x3d(0)*sin(alpha_)+z3d(0)*cos(alpha_) - z) + coorx
                                zn = (x3d(n_)*sin(alpha_)+z3d(n_)*cos(alpha_) - z) +  coorx
                                 //x3d(0)*(1 - tmp) + x3d(n_)*(tmp),  y3d(0)*(1 - tmp) + y3d(n_)*(tmp),  z3d(0)*(1 - tmp) + z3d(n_)*(tmp)
                                proby.printf("%d %d %d %f %f %f\n",cell, comp,l ,x0*(1 - tmp) + xn*(tmp),  y0*(1 - tmp) + yn*(tmp),  z0*(1 - tmp) + zn*(tmp))
                                geometry.printf("%d %d %d %f %f %f %f %f %f %f\n",cell, comp,l ,x0,  y0,  z0, xn,  yn,  zn, (diam/2))
                                
                                }

                }

               //proby.printf("\n", i)


           cell = cell + 1
        }
}


objref ve,dens,dens_tmp,results,f
dens = new Matrix()
ve = new Vector(37,0)
{ve.indgen(-1850,-50,50)}

dens_tmp = new Vector()

f = new File("norm_dens.txt")
{f.ropen()
dens.scanf(f,Map_names.count()-2,37)
f.close()}


for j =1, powtorzenia{

sprint(str2, "dat/nodes/test_7.1/nodes_%d.dat",j)
sprint(str3, "dat/geometry/test_7.1/points_%d.dat",j)
proby.wopen(str2)
cell = 0
/*
    for k = 0,11{
        dens.getrow(k,dens_tmp)
        results= emp_random(ve,dens_tmp,Num_pop.x(k))
        write_nodes(Map_names.o(k).s, Num_pop.x(k),results)
        }*/

write_nodes("suppyrRS", num_suppyrRS,-glebokosc_poziomu23,0)
write_nodes("suppyrFRB", num_suppyrFRB,-glebokosc_poziomu23,0)
write_nodes("supbask", num_supbask,-glebokosc_poziomu23,0)
write_nodes("supaxax", num_supaxax,-glebokosc_poziomu23, 0)
write_nodes("supLTS", num_supLTS, -glebokosc_poziomu23, 0)
write_nodes("spinstell", num_spinstell, -glebokosc_poziomu4, poziom23)
write_nodes("tuftIB", num_tuftIB, -glebokosc_poziomu5, poziom4)
write_nodes("tuftRS", num_tuftRS, -glebokosc_poziomu5,  poziom4)
write_nodes("nontuftRS", num_nontuftRS, -glebokosc_poziomu6, poziom5)
write_nodes("deepbask", num_deepbask, -glebokosc_poziomu5 -glebokosc_poziomu6, poziom4)
write_nodes("deepaxax", num_deepaxax, -glebokosc_poziomu5 -glebokosc_poziomu6, poziom4)
write_nodes("deepLTS", num_deepLTS, -glebokosc_poziomu5 -glebokosc_poziomu6, poziom4)
write_nodes("TCR", num_TCR, -100, -3000)
write_nodes("nRT", num_nRT, -100,-3100)

//write_nodes("TCR", num_TCR,new Vector(100,-5000))
//write_nodes("nRT", num_nRT,new Vector(100,-4000))

proby.close
geometry.close
print my_cell
}